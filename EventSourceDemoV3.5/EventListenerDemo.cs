// Copyright (c) Microsoft Corporation.  All rights reserved
using System;
using System.Diagnostics.Tracing;

class EventListenerDemo
{
    /// <summary>
    /// In addition to EventSource, the framework also defines EventListener, which is 
    /// a class that recieves the data that EventSources create.   If you are using
    /// ETW as your target, then you probably don't care about EventListeners, but if you 
    /// want you data to go elsewhere then EventListeners provide that capability.  
    /// 
    /// The basic model is that events generated by EventSources go to all defined EventListerns
    /// and the framework happens to define a EventListener that sends the data to the ETW pipe.
    /// 
    /// Each listener gets to define which filtering Keywords and Level it wants.  
    /// 
    /// Once created EVentListerns get callbacks on their 'OnEventSourceCreated' and 
    /// 'OnEventWritten' methods.  
    /// 
    /// </summary>
    public static void UserDefinedEventListeners()
    {
        // Create some streams to test registering without using the ETW backend.  
        EventListener myListener0 = new MyListener("Listener 0");
        EventListener myListener1 = new MyListener("Listener 1");

        // Turn on some of the eventSources for some of the streams.  
        myListener0.EnableEvents(MinimalEventSource.Log, EventLevel.Verbose);
        myListener1.EnableEvents(MinimalEventSource.Log, EventLevel.Verbose);
        myListener1.EnableEvents(AdvancedEventSource.Log, EventLevel.Verbose);

        MinimalEventSource.Log.Message("Listener 0 dieing.");
        myListener0.Dispose();
        MinimalEventSource.Log.Message("Listener 2 creating.");
        EventListener myListener2 = new MyListener("Listener 2");
        MinimalEventSource.Log.Message("Listener 2 created");

        foreach(var source in EventSource.GetSources())
            myListener1.EnableEvents(source, EventLevel.Verbose);
        MinimalEventSource.Log.Message("Listener 2 log messages are on.");

        MinimalEventSource.Log.Unload(11);
        MinimalEventSource.Log.Unload(10);
        //MinimalEventSource.Log.SetGuid(new Guid(0xc836fd3, 0xee92, 0x4301, 0xbc, 0x13, 0xd8, 0x94, 0x3e, 0xc, 0x1e, 0x77));

        AdvancedEventSource.Log.AnotherEvent(1, "", 2);
        // A full eventLogger.  You create this unconditionally and is very cheap if not
        // activated.  See code:AdvancedEventSource about how to turn on logging.  
            
        // Here are a bunch of events (in a row!)
        AdvancedEventSource.Log.TaskCreate(0x10);

        AdvancedEventSource.Log.ImageStart(0x129, 35, "This is a relatively long name ");
        AdvancedEventSource.Log.TaskCreate(0x10);
        AdvancedEventSource.Log.RunStart(0x11);
        AdvancedEventSource.Log.RunStop(0x12);
        AdvancedEventSource.Log.EmptyEvent();
        AdvancedEventSource.Log.RunStart(0x111);
        AdvancedEventSource.Log.RunStop(0x112);
        AdvancedEventSource.Log.SetGuid(new Guid(0xc836fd3, 0xee92, 0x4301, 0xbc, 0x13, 0xd8, 0x94, 0x3e, 0xc, 0x1e, 0x77));
        AdvancedEventSource.Log.AnotherEvent(100, "(Numbers should be 100, 101)", 101);

        AnotherEventSource anotherEventSource = new AnotherEventSource();
        anotherEventSource.Message("This is from AnotherEventSource");

        MinimalEventSource.Log.Message("Message from MinimalEventSource.");
        AdvancedEventSource.Log.Message("Message from AdvancedEventSource.");

        Console.WriteLine("Sleeping 3 seconds");
        System.Threading.Thread.Sleep(1000 * 3);
        Console.WriteLine("Finished Sleeping");
    }
}

/// <summary>
/// This is an advanced useage, where you want to intercept the logging messages and devert them somewhere
/// besides ETW.
/// </summary>
class MyListener : EventListener
{
    public MyListener(string name)
    {
        this.name = name;
        Console.WriteLine("MyListener for {0} has name {1}", GetHashCode(), name);
    }
    protected override void OnEventWritten(EventWrittenEventArgs eventData)
    {

        Console.Write("{0} Got event {1} eventSource {2,18} args[{3}] = ", name, eventData.EventId, eventData.EventSource.Name, eventData.Payload.Count);
        foreach (object arg in eventData.Payload)
        {
            Byte[] asByteArray = arg as Byte[];
            if (asByteArray != null)
                Console.Write("Byte[" + asByteArray.Length.ToString() + "]");
            else
                Console.Write(arg.ToString() + " ");
        }
        Console.WriteLine();
    }
    protected override void OnEventSourceCreated(EventSource eventSource)
    {
        Console.WriteLine("OnEventSourceCreated for Listener {0} {1} got eventSource {2}", GetHashCode(), name, eventSource.Name);

        if (name == "Listener 2")
        {
            Console.WriteLine("Turning on all Events for Listener 2");
            EnableEvents(eventSource, EventLevel.Verbose);
        }
    }
    string name;
}

sealed class AnotherEventSource : EventSource
{
    public void Load(long ImageBase, string Name) { if (IsEnabled()) WriteEvent(1, ImageBase, Name); }
    public void Unload(long ImageBase) { if (IsEnabled()) WriteEvent(2, ImageBase); }
    public void SetGuid(Guid MyGuid) { if (IsEnabled()) WriteEvent(3, MyGuid); }
    public void Message(string Message) { if (IsEnabled()) WriteEvent(4, Message); }
}